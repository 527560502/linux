#include <linux/kernel.h>#include <linux/module.h>#include <linux/i2c.h>#include <linux/cdev.h>#include <linux/slab.h>#include <linux/fs.h>#include <linux/delay.h>#include <asm/uaccess.h>#include <linux/device.h>MODULE_LICENSE("GPL");#include "bmi160.h"dev_t devno;static struct class *bmi_class;struct bmi160_device { struct cdev cdev; struct i2c_client *client;};struct bmi160_device *bmi160; static int bmi160_read_byte(struct i2c_client *client, unsigned char reg){ int ret; char txbuf[1] = { reg }; char rxbuf[1]; struct i2c_msg msg[2] = {  {client->addr, 0, 1, txbuf},  {client->addr, I2C_M_RD, 1, rxbuf} }; ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg)); if (ret < 0) {  return ret; } return rxbuf[0];}static int bmi160_write_byte(struct i2c_client *client, unsigned char reg, unsigned char val){ char txbuf[2] = {reg, val}; struct i2c_msg msg[2] = {  {client->addr, 0, 2, txbuf}, }; i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg)); return 0;}static int bmi160_open(struct inode *inode, struct file *file) { //printk("open\n"); return 0;}static int bmi160_release(struct inode *inode, struct file *file) { //printk("close\n"); return 0;}static long bmi160_ioctl(struct file *file, unsigned int cmd, unsigned long arg){  union bmi160_data data; switch(cmd)  { case GET_ACCEL:        data.accel.x  = bmi160_read_byte(bmi160->client, 0x12);  data.accel.x |= bmi160_read_byte(bmi160->client, 0x13) << 8;  data.accel.y  = bmi160_read_byte(bmi160->client, 0x14);  data.accel.y |= bmi160_read_byte(bmi160->client, 0x15) << 8;  data.accel.z  = bmi160_read_byte(bmi160->client, 0x16);  data.accel.z |= bmi160_read_byte(bmi160->client, 0x17) << 8;  break; case GET_GYRO:        data.gyro.x   = bmi160_read_byte(bmi160->client, 0x0c);  data.gyro.x  |= bmi160_read_byte(bmi160->client, 0x0d) << 8;  data.gyro.y   = bmi160_read_byte(bmi160->client, 0x0e);  data.gyro.y  |= bmi160_read_byte(bmi160->client, 0x0f) << 8;  data.gyro.z   = bmi160_read_byte(bmi160->client, 0x10);  data.gyro.z  |= bmi160_read_byte(bmi160->client, 0x11) << 8;        break; default:  printk("invalid argument\n");  return -EINVAL; } /*拷贝内核数据*/ if (copy_to_user((void*)arg, &data, sizeof(data)))   return EFAULT; return sizeof(data);}struct file_operations bmi160_fops = { .owner   = THIS_MODULE, .open  = bmi160_open, .release  = bmi160_release, .unlocked_ioctl = bmi160_ioctl,};//I2C设备驱动与client匹配成功回调此函数static int bmi160_probe(struct i2c_client *client, const struct i2c_device_id *id){ int ret; char CHIP_ID = 0; struct device *bmi_device; devno = MKDEV(BMI160_MAJOR, BMI160_MINOR); printk("match OK!\n");    bmi160 = kzalloc(sizeof(*bmi160), GFP_KERNEL); if(bmi160 == NULL) {  return -ENOMEM; }  bmi160->client = client; ret = register_chrdev_region(devno, 1, "bmi160"); if (ret < 0) {   printk("failed to register char device region!\n");  goto err1; } cdev_init(&bmi160->cdev, &bmi160_fops); bmi160->cdev.owner = THIS_MODULE; ret = cdev_add(&bmi160->cdev, devno, 1); if (ret < 0) {  printk("failed to add device\n");  goto err2; } /*创建设备类*/ bmi_class = class_create(THIS_MODULE, "BMI"); if (IS_ERR(bmi_class)) {   goto err3; } bmi_device = device_create(bmi_class, NULL, devno, NULL, "bmi160"); if (IS_ERR(bmi_device)) {  goto err4; }    CHIP_ID = bmi160_read_byte(bmi160->client, 0x00);    printk("CHIP_ID = 0x%02x\n", CHIP_ID);        //1 work mode    bmi160_write_byte(bmi160->client, 0x7e, 0x11);    bmi160_write_byte(bmi160->client, 0x7e, 0x15);  return 0;err4:    class_destroy(bmi_class);err3: cdev_del(&bmi160->cdev);err2: unregister_chrdev_region(devno, 1);err1:    kfree(bmi160); return ret;}static int bmi160_remove(struct i2c_client * client){    printk("bmi160 remove\n"); devno = MKDEV(BMI160_MAJOR, BMI160_MINOR); cdev_del(&bmi160->cdev); unregister_chrdev_region(devno, 1); /*删除设备节点和设备类*/ device_destroy(bmi_class, devno);      class_destroy(bmi_class); kfree(bmi160); return 0;}struct i2c_device_id bmi160_id[] = { { "BMI160", 0}, {},}; //I2C设备驱动结构体struct i2c_driver bmi160_driver = { .driver = {  .name    = "BMI160",  .owner    = THIS_MODULE, }, .probe   = bmi160_probe, .remove  = bmi160_remove, .id_table  = bmi160_id,};//module_i2c_driver(bmi160_driver);static int __init bmi160_init(void){  return i2c_add_driver(&bmi160_driver);}static void __exit bmi160_exit(void){  i2c_del_driver(&bmi160_driver);}module_init(bmi160_init);module_exit(bmi160_exit);
